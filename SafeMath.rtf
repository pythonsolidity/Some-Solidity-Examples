{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 pragma solidity ^0.5.5;\
\
/**\
 * @title SafeMath\
 * @dev Unsigned math operations with safety checks that revert on error\
 */\
library SafeMath \{\
    /**\
     * @dev Multiplies two unsigned integers, reverts on overflow.\
     */\
    function mul(uint256 a, uint256 b) internal pure returns (uint256) \{\
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\
        // benefit is lost if 'b' is also tested.\
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\
        if (a == 0) \{\
            return 0;\
        \}\
\
        uint256 c = a * b;\
        require(c / a == b);\
\
        return c;\
    \}\
\
    /**\
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\
     */\
    function div(uint256 a, uint256 b) internal pure returns (uint256) \{\
        // Solidity only automatically asserts when dividing by 0\
        require(b > 0);\
        uint256 c = a / b;\
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\
\
        return c;\
    \}\
\
    /**\
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\
     */\
    function sub(uint256 a, uint256 b) internal pure returns (uint256) \{\
        require(b <= a);\
        uint256 c = a - b;\
\
        return c;\
    \}\
\
    /**\
     * @dev Adds two unsigned integers, reverts on overflow.\
     */\
    function add(uint256 a, uint256 b) internal pure returns (uint256) \{\
        uint256 c = a + b;\
        require(c >= a);\
\
        return c;\
    \}\
\
    /**\
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\
     * reverts when dividing by zero.\
     */\
    function mod(uint256 a, uint256 b) internal pure returns (uint256) \{\
        require(b != 0);\
        return a % b;\
    \}\
\}}